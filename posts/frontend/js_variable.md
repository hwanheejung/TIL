# **변수는 값이 아니라 메모리 주소를 저장한다.**

# 1. 메모리에서 벌어지는 일

우선 사람과 컴퓨터를 비교해보자. `10 + 20`을 실행하면,

- 사람

  1.  10과 20을 두뇌에 기억한다.
  2.  10 + 20을 수행하고, 결과값인 30도 두뇌에 기억한다.

- 컴퓨터(JS 엔진)
  1. 10과 20을 메모리에 기억한다.
  2. CPU에서 10 + 20을 수행하고, 결과값인 30을 메모리에 기억한다.

| 구분   | 계산 | 기억   |
| ------ | ---- | ------ |
| 사람   | 두뇌 | 두뇌   |
| 컴퓨터 | CPU  | 메모리 |

![4-2](https://velog.velcdn.com/images/hwanheejung/post/520e6d11-7d0d-460e-8d22-2b2b595583f6/image.jpeg)

여기까진 오케이. 그런데 우리는 프로그래밍을 하면서 값을 재사용하는 일이 빈번하다. 결과값인 30을 재사용하고 싶다면, 30에 접근하는 방법은 **오로지 30이 저장된 메모리 주소에 직접 접근하는 방법밖엔 없다**

- 하지만 이 방법은 운영체제가 사용하고 있는 값이 변경될 경우, 시스템이 멈춰버리는 치명적인 오류가 발생한다. (안전하지 않음)

- 메모리 주소 직접 접근을 허용하더라도 코드가 실행될 때마다 값이 저장되는 주소는 바뀌기 때문에 코드 실행 전에는 저장될 메모리 주소를 알 수 없다. 따라서 애초에 접근이 불가하다.

그렇다면 값에 접근하는 안전한 방법은 무엇인가?

<br />

# 2. 변수의 등장

1. 코드 실행 후, 결과값 30이 임의의 메모리 주소 100번지에 저장됐다.
2. 100번지에 banana라는 변수의 이름을 붙인다.
3. 코드가 재실행되면, 값이 저장되는 위치가 235번지로 바뀌었다.
4. 235번지의 이름은 banana이다.

![4-3](https://velog.velcdn.com/images/hwanheejung/post/f39ed39c-81cc-4233-8256-666ec094fbcf/image.jpeg)

결국, 메모리 주소는 변경되었지만, banana라는 이름은 변하지 않는다. 메모리 주소에 직접 접근하지 않고도 변수를 통해 안전하게 값에 접근했다!

> 변수란, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 즉, 값의 위치를 가리키는 상징적인 이름이다.

- 변수명(식별자): banana
- 변수값: 30
- 할당(assignment): 변수에 값을 저장하는 것
- 참조(reference): 변수값을 읽어오는 것

<br />

# 3. Declaration. 변수 선언

변수를 생성하는 과정은 다음과 같다.

1. 메모리 공간 확보 (allocate)
2. 변수명과 메모리 공간의 주소 연결 (name binding)

이때 만들어진 공간은 garbage collector에 의해 해제(release)되기 전에는 사라지지 않고 보호된다.

<br />

### 3.1 선언만 하고 값을 할당하지 않은 경우

```javascript
var score; // undefined
```

여기서 javascript만의 독특한 특징을 확인할 수 있다. score라는 변수를 선언을 하고, 값은 할당하지 않았으니 해당 메모리 주소는 빈 공간이지 않을까? 라고 생각할 수 있지만, javascript에서는 그렇지 않다. 전에 썼던 쓰레기 값(garbage value)이 지워지지 않고 남아있을 수도 있기 때문이다.

따라서 항상 `선언`후, primitive value인 undefined를 최초로 할당하는 `초기화` 단계를 거친다.

- 값이 할당되지 않아도 undefined로 초기화되기 때문에, var 키워드는 garbage value가 나올 위험이 없다!

> > _Q. 그렇다면 let과 const는 쓰레기값이 나올 가능성이 있다는 뜻인가..?_

<br />

### 3.2 선언을 하지 않았다면?

선언을 하지 않았다는 말은 allocate, name binding을 하지 않았다는 의미이다. 따라서 선언하지 않은 식별자에 접근하려고 시도해도 js 엔진이 식별자를 찾지 못해서 ReferenceError(참조 에러)가 발생한다.

<br />

# 4. 변수 호이스팅

- runtime: 소스 코드가 한 줄씩 순차적으로 실행되는 시점

js 엔진은 runtime 이전에 소스코드의 `평가과정`을 거친다. 모든 선언문은 runtime 이전에 실행한다. 따라서 변수 선언이 소스코드의 어디에 있든 다른 코드보다 먼저 실행되기 때문에 상관없다.

> 변수 호이스팅이란, 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 js 고유의 특징이다.

```javascript
console.log(score); // 2) runtime에 실행. undefined
var score; // 1) runtime 이전에 실행
```

<br />

# 5. Assignment. 값의 할당

변수 선언과 값의 할당은 실행 시점이 다르다.

1. declaration : runtime 이전 평가과정 때 실행
2. assignment : runtime에 실행

따라서, 선언과 할당을 하나의 문으로 단축해서 표현해도 js 엔진은 알아서 두 개의 문으로 나누어 각각 실행한다.

```javascript
var score = 80; // 1) declaration 2) assignment
```

```javascript
console.log(score); // 2) undefined

var score; // 1) runtime 이전 평가과정 때 실행
score = 80; // 3) 값 할당

console.log(score); // 4) 80
```

<br />

### 5.1 값의 재할당

![4-4](https://velog.velcdn.com/images/hwanheejung/post/bc127ee6-1731-4f08-b9c0-939df6a8bb9f/image.jpeg)

값의 재할당으로 인해 더이상 필요없어진 메모리 공간들은 garbage collector에 의해 메모리에서 자동 해제됨으로써 메모리 누수를 방지한다.
